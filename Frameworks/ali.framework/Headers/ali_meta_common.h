#pragma once

#include "ali/ali_features.h"
#include <type_traits>

namespace ali
{

namespace meta
{

// ******************************************************************
struct empty_type {};
// ******************************************************************

// ******************************************************************
// ******************************************************************

// ******************************************************************
typedef char yes_type;
// ******************************************************************

// ******************************************************************
struct no_type { char _[2]; };
// ******************************************************************

// ******************************************************************
// ******************************************************************

// ******************************************************************
template <typename T, T value>
struct define_result
// ******************************************************************
{
    static T const result = value;
};

// ******************************************************************
// ******************************************************************

// ******************************************************************
template <bool value>
struct define_bool_result
// ******************************************************************
    :   define_result<bool, value> {};

// ******************************************************************    
struct define_true_result
// ******************************************************************
    :   define_bool_result<true> {};
    
// ******************************************************************    
struct define_false_result
// ******************************************************************
    :   define_bool_result<false> {};
    
// ******************************************************************
// ******************************************************************

// ******************************************************************    
template <typename T>
struct define_type
// ******************************************************************
{
    using type = T;
};

// ******************************************************************
// ******************************************************************

// ******************************************************************
template <typename T>
T make( void ) noexcept;
// ******************************************************************

// ******************************************************************
// ******************************************************************

// ******************************************************************
template <typename T>
void take( typename define_type<T>::type ) noexcept;
// ******************************************************************

// ******************************************************************
// ******************************************************************

#ifdef  ALI_FEATURE_VARIADIC_TEMPLATES

// ******************************************************************
template <int a, int... rest>
struct maxi
// ******************************************************************
    :   define_result<int, maxi<a, maxi<rest...>::result>::result> {};

// ******************************************************************
template <int a>
struct maxi<a>
// ******************************************************************
    :   define_result<int, a> {};

// ******************************************************************
template <int a, int b>
struct maxi<a, b>
// ******************************************************************
    :   define_result<int, (b > a ? b : a)> {};

// ******************************************************************
// ******************************************************************

// ******************************************************************
template <int a, int... rest>
struct mini
// ******************************************************************
    :   define_result<int, mini<a, mini<rest...>::result>::result> {};

// ******************************************************************
template <int a>
struct mini<a>
// ******************************************************************
    :   define_result<int, a> {};

// ******************************************************************
template <int a, int b>
struct mini<a, b>
// ******************************************************************
    :   define_result<int, (b < a ? b : a)> {};

// ******************************************************************
// ******************************************************************

#else   //  !ALI_FEATURE_VARIADIC_TEMPLATES

// ******************************************************************
template <int a, int b>
struct maxi
// ******************************************************************
    :   define_result<int, (b > a ? b : a)> {};

// ******************************************************************
// ******************************************************************

// ******************************************************************
template <int a, int b>
struct mini
// ******************************************************************
    :   define_result<int, (b < a ? b : a)> {};

// ******************************************************************
// ******************************************************************

#endif  //  ALI_FEATURE_VARIADIC_TEMPLATES

#ifdef  ALI_FEATURE_VARIADIC_TEMPLATES

// ******************************************************************
template <int idx, typename... ts>
struct type_at;
// ******************************************************************

// ******************************************************************
template <typename head, typename... rest>
struct type_at<0, head, rest...>
// ******************************************************************
    : define_type<head> {};

// ******************************************************************
template <int idx, typename head, typename... rest>
struct type_at<idx, head, rest...>
// ******************************************************************
    : define_type<typename type_at<idx - 1, rest...>::type> {};

#endif  //  ALI_FEATURE_VARIADIC_TEMPLATES

// ******************************************************************
// ******************************************************************

// ******************************************************************
template <bool condition, typename _true, typename _false>
struct select;
// ******************************************************************

template <typename _true, typename _false>
struct select<false, _true, _false>
    :   define_type<_false> {};

template <typename _true, typename _false>
struct select<true, _true, _false>
    :   define_type<_true> {};

// ******************************************************************
// ******************************************************************

// ******************************************************************
template <
    bool condition,
    typename param,
    template <typename> class _true,
    template <typename> class _false>
struct template_select;
// ******************************************************************

template <
    typename param,
    template <typename> class _true,
    template <typename> class _false>
struct template_select<false, param, _true, _false>
    :   define_type<_false<param> > {};

template <
    typename param,
    template <typename> class _true,
    template <typename> class _false>
struct template_select<true, param, _true, _false>
    :   define_type<_true<param> > {};

// ******************************************************************
// ******************************************************************

// ******************************************************************
template <bool a, bool b>
struct _or;
// ******************************************************************

template <bool b>
struct _or<true, b>
    :   define_bool_result<true> {};

template <bool b>
struct _or<false, b>
    :   define_bool_result<b> {};

// ******************************************************************
// ******************************************************************

// ******************************************************************
template <bool a, bool b>
struct _and;
// ******************************************************************
template <bool b>
struct _and<false, b>
    :   define_bool_result<false> {};

template <bool b>
struct _and<true, b>
    :   define_bool_result<b> {};

// ******************************************************************
// ******************************************************************

template <typename T>
struct has_virtual_destructor
    :   define_bool_result<std::has_virtual_destructor<T>::value> {};

// ******************************************************************
// ******************************************************************

template <typename T>
struct is_polymorphic
    :   define_bool_result<std::is_polymorphic<T>::value> {};

// ******************************************************************
// ******************************************************************

#ifdef __clang__
//  KLUDGE: libstdc++ for Debian 9 doesn't define
//  std::is_trivially_copyable. As we are using clang
//  for those builds, we use the __clang__ macro for
//  workaround.

template <typename T>
struct is_trivially_copyable
    :   define_bool_result<__is_trivially_copyable(T)> {};

#else   //  !__clang__

template <typename T>
struct is_trivially_copyable
    :   define_bool_result<std::is_trivially_copyable<T>::value> {};

#endif  //  __clang__

// ******************************************************************
// ******************************************************************

// ******************************************************************
template <typename T>
struct is_pointer
// ******************************************************************
    :   define_false_result {};

template <typename T>
struct is_pointer<T*>
    :   define_true_result {};
// ******************************************************************
// ******************************************************************

// ******************************************************************
template <typename T>
struct is_const
// ******************************************************************
    :   define_false_result {};

template <typename T>
struct is_const<T const>
    :   define_true_result {};
// ******************************************************************
// ******************************************************************

// ******************************************************************
template <typename T>
struct is_volatile
// ******************************************************************
    :   define_false_result {};

template <typename T>
struct is_volatile<T volatile>
    :   define_true_result {};
// ******************************************************************
// ******************************************************************

// ******************************************************************
template <typename T>
struct remove_c
// ******************************************************************
    :   define_type<T> {};
    
template <typename T>
struct remove_c<T const>
    :   define_type<T> {};
// ******************************************************************
// ******************************************************************

// ******************************************************************
template <typename T>
struct remove_v
// ******************************************************************
    :   define_type<T> {};
    
template <typename T>
struct remove_v<T volatile>
    :   define_type<T> {};
// ******************************************************************
// ******************************************************************

// ******************************************************************
template <typename T>
struct is_ref
// ******************************************************************
    :   define_false_result {};

template <typename T>
struct is_ref<T&>
    :   define_true_result {};

template <typename T>
struct is_ref<T&&>
    :   define_true_result {};

// ******************************************************************
// ******************************************************************
template <typename T>
struct remove_ref
// ******************************************************************
    :   define_type<T> {};

template <typename T>
struct remove_ref<T&>
    :   define_type<T> {};

template <typename T>
struct remove_ref<T&&>
    :   define_type<T> {};

// ******************************************************************
// ******************************************************************

// ******************************************************************
template <typename T, typename U>
struct is_same_type
// ******************************************************************
    :   define_false_result {};

template <typename T>
struct is_same_type<T, T>
    :   define_true_result {};

// ******************************************************************
// ******************************************************************

// ******************************************************************
template<bool,
         typename T = void>
struct enable_if {};
// ******************************************************************

template <typename T>
struct enable_if<true, T>
    :   define_type<T> {};

// ******************************************************************
// ******************************************************************


}   //  namespace meta

}   //  namespace ali
